use rstest::rstest;

use crate::pep508::{Requirement, VersionOp};

#[test]
fn debug_version_parsing() {
    let versions = vec![
        ">=2.7.0rc1",
        ">=2.7rc1", 
        ">=2rc1",
    ];
    
    for v_str in versions {
        let vo = VersionOp::new(v_str).unwrap();
        println!("\n=== Parsing: {} ===", v_str);
        println!("  epoch: {:?}", vo.version.epoch);
        println!("  release: {:?}", vo.version.release);
        println!("  pre: {:?}", vo.version.pre);
        println!("  post: {:?}", vo.version.post);
        println!("  dev: {:?}", vo.version.dev);
        println!("  local: {:?}", vo.version.local);
        println!("  Display: {}", vo.version);
    }
}

#[rstest]
#[case::lowercase("A", "a")]
#[case::replace_dot_with_dash("a.b", "a-b")]
fn test_get_canonic_requirement_name(#[case] start: &str, #[case] expected: &str) {
    assert_eq!(Requirement::new(start).unwrap().canonical_name(), expected);
}
#[rstest]
#[case::strip_version(
    r#"requests [security , tests] >= 2.0.0, == 2.8.* ; (os_name=="a" or os_name=='b') and os_name=='c' and python_version > "3.8""#,
    "requests[security,tests]>=2,==2.8.*; (os_name=='a' or os_name=='b') and os_name=='c' and python_version>'3.8'",
    false
)]
#[case::keep_version(
r#"requests [security , tests] >= 2.0.0, == 2.8.* ; (os_name=="a" or os_name=='b') and os_name=='c' and python_version > "3.8""#,
"requests[security,tests]>=2.0.0,==2.8.*; (os_name=='a' or os_name=='b') and os_name=='c' and python_version>'3.8'",
true
)]
#[case::do_not_strip_tilda("a~=3.0.0", "a~=3.0.0", false)]
#[case::url(
    " pip   @   https://github.com/pypa/pip/archive/1.3.1.zip#sha1=da9234ee9982d4bbb3c72346a6de940a148ea686 ",
    "pip @ https://github.com/pypa/pip/archive/1.3.1.zip#sha1=da9234ee9982d4bbb3c72346a6de940a148ea686",
    true
)]
#[case::keep_rc_version("a==5.2rc1", "a==5.2rc1", true)]
#[case::issue_py_cord_first("py-cord>=2.7.0rc1", "py-cord>=2.7rc1", false)]
fn test_format_requirement(#[case] start: &str, #[case] expected: &str, #[case] keep_full_version: bool) {
    let got = Requirement::new(start)
        .unwrap()
        .normalize(keep_full_version)
        .to_string();
    assert_eq!(got, expected);
    // formatting remains stable
    assert_eq!(
        Requirement::new(got.as_str())
            .unwrap()
            .normalize(keep_full_version)
            .to_string(),
        expected
    );
}

#[test]
fn test_rc_version_stability() {
    // Test case from issue - should not strip version parts from pre-release versions
    let input = "py-cord>=2.7.0rc1";
    
    // First normalization
    let req1 = Requirement::new(input).unwrap().normalize(false);
    let result1 = req1.to_string();
    println!("Input:            {}", input);
    println!("First normalize:  {}", result1);
    
    // Second normalization
    let req2 = Requirement::new(&result1).unwrap().normalize(false);
    let result2 = req2.to_string();
    println!("Second normalize: {}", result2);
    
    // Third normalization
    let req3 = Requirement::new(&result2).unwrap().normalize(false);
    let result3 = req3.to_string();
    println!("Third normalize:  {}", result3);
    
    // The problem: first run produces "2.7rc1" which is correct
    // But the second run on "2.7rc1" treats "rc1" as part of release,
    // then strips the trailing .0 and produces "2rc1" which is wrong!
    
    // Should stabilize and NOT become "py-cord>=2rc1"
    assert_eq!(result1, result2, "First and second normalization should match - FAILS: produces py-cord>=2rc1 on second run");
    assert_eq!(result2, result3, "Second and third normalization should match");
}

#[test]
fn test_version_without_dot_before_rc() {
    // Test parsing versions where there's no dot before rc
    let test_cases = vec![
        ("pkg>=2rc1", ">=2rc1"),
        ("pkg>=2.7rc1", ">=2.7rc1"),
        ("pkg>=2.7.0rc1", ">=2.7rc1"), // normalizes to 2.7rc1
    ];
    
    for (input, expected_version_part) in test_cases {
        let req = Requirement::new(input).unwrap().normalize(false);
        let result = req.to_string();
        println!("Input: {}, Result: {}", input, result);
        assert!(result.contains(expected_version_part), 
            "Expected {} to contain {}", result, expected_version_part);
    }
}

#[test]
fn test_deep_version_structure() {
    let inputs = vec![
        "pkg>=2.7.0rc1",
        "pkg>=2.7rc1",
        "pkg>=2rc1",
    ];
    
    for input in inputs {
        let req = Requirement::new(input).unwrap().normalize(false);
        let vo = match &req.version_or_url {
            Some(crate::pep508::requirement::VersionOrUrl::Versions(specs)) => &specs[0],
            _ => panic!("Expected version"),
        };
        
        println!("\n=== Input: {} ===", input);
        println!("  release: {:?}", vo.version.release);
        println!("  pre: {:?}", vo.version.pre);
        println!("  output: {}", req);
        
        // Now parse the output and check again
        let output_str = req.to_string();
        let req2 = Requirement::new(&output_str).unwrap().normalize(false);
        let vo2 = match &req2.version_or_url {
            Some(crate::pep508::requirement::VersionOrUrl::Versions(specs)) => &specs[0],
            _ => panic!("Expected version"),
        };
        
        println!("After round-trip:");
        println!("  release: {:?}", vo2.version.release);
        println!("  pre: {:?}", vo2.version.pre);
        println!("  output: {}", req2);
        
        assert_eq!(vo.version.release, vo2.version.release, 
            "Release should be stable for {}", input);
    }
}
